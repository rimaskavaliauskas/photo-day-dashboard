{
  "version": 3,
  "sources": ["../bundle-V5gIrh/checked-fetch.js", "../bundle-V5gIrh/strip-cf-connecting-ip-header.js", "../../../src/lib/geo.ts", "../../../src/handlers/dashboard.ts", "../../../src/handlers/set-location.ts", "../../../src/lib/sheets-sync.ts", "../../../src/lib/sun.ts", "../../../src/handlers/my-places.ts", "../../../src/lib/weather-score.ts", "../../../src/cron/places-and-weather.ts", "../../../src/cron/youtube-sync.ts", "../../../src/index.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-V5gIrh/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-V5gIrh/middleware-loader.entry.ts"],
  "sourceRoot": "D:\\AI\\aleksandras-2-dalis\\dashboard\\worker\\.wrangler\\tmp\\dev-BcmXVj",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/**\n * Geographic Utilities\n * Distance calculations, coordinate helpers\n */\n\n/**\n * Calculate distance between two points using Haversine formula\n * @returns Distance in kilometers\n */\nexport function haversineDistance(\n  lat1: number,\n  lng1: number,\n  lat2: number,\n  lng2: number\n): number {\n  const R = 6371; // Earth's radius in km\n  const dLat = toRadians(lat2 - lat1);\n  const dLng = toRadians(lng2 - lng1);\n  \n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(toRadians(lat1)) *\n      Math.cos(toRadians(lat2)) *\n      Math.sin(dLng / 2) *\n      Math.sin(dLng / 2);\n  \n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  \n  return R * c;\n}\n\nfunction toRadians(degrees: number): number {\n  return degrees * (Math.PI / 180);\n}\n\n/**\n * Parse a location string that might be \"lat,lng\" format\n * @returns [lat, lng] or null if not parseable\n */\nexport function parseLatLng(locationStr: string): [number, number] | null {\n  if (!locationStr) return null;\n  \n  // Try \"lat,lng\" or \"lat, lng\" format\n  const parts = locationStr.split(',').map(s => s.trim());\n  if (parts.length !== 2) return null;\n  \n  const lat = parseFloat(parts[0]);\n  const lng = parseFloat(parts[1]);\n  \n  if (isNaN(lat) || isNaN(lng)) return null;\n  if (lat < -90 || lat > 90) return null;\n  if (lng < -180 || lng > 180) return null;\n  \n  return [lat, lng];\n}\n\n/**\n * Calculate a bounding box for a given center point and radius\n * @param lat Center latitude\n * @param lng Center longitude\n * @param radiusKm Radius in kilometers\n * @returns { minLat, maxLat, minLng, maxLng }\n */\nexport function getBoundingBox(\n  lat: number,\n  lng: number,\n  radiusKm: number\n): { minLat: number; maxLat: number; minLng: number; maxLng: number } {\n  // Approximate: 1 degree lat = 111 km\n  // 1 degree lng = 111 km * cos(lat)\n  const latDelta = radiusKm / 111;\n  const lngDelta = radiusKm / (111 * Math.cos(toRadians(lat)));\n  \n  return {\n    minLat: lat - latDelta,\n    maxLat: lat + latDelta,\n    minLng: lng - lngDelta,\n    maxLng: lng + lngDelta,\n  };\n}\n\n/**\n * Format coordinates for display\n */\nexport function formatCoords(lat: number, lng: number): string {\n  return `${lat.toFixed(4)}, ${lng.toFixed(4)}`;\n}\n", "import { Env, DashboardResponse, UserSettings, SunWindow, WeatherSlot, Place, TaskWindow, YouTubeVideo, PlaceWithDistance, TaskWindowWithTask } from '../types';\nimport { haversineDistance } from '../lib/geo';\n\n/**\n * GET /api/dashboard\n * \n * Returns all dashboard data in a single response:\n * - Current location (from settings or CF geolocation)\n * - Sun windows for today/tomorrow\n * - Weather slots with photo day score\n * - Nearby places\n * - Recommended task windows\n * - Latest YouTube videos\n */\nexport async function handleDashboard(\n  env: Env,\n  cfLat?: number,\n  cfLng?: number\n): Promise<DashboardResponse> {\n  const db = env.DB;\n  \n  // 1. Get current location from user_settings (or use CF/defaults)\n  const settings = await db\n    .prepare('SELECT * FROM user_settings WHERE id = 1')\n    .first<UserSettings>();\n  \n  let lat: number;\n  let lng: number;\n  let source: string;\n  \n  if (settings && settings.base_lat && settings.base_lng) {\n    lat = settings.base_lat;\n    lng = settings.base_lng;\n    source = settings.last_geo_source;\n  } else if (cfLat && cfLng) {\n    // Use Cloudflare's IP-based geolocation\n    lat = cfLat;\n    lng = cfLng;\n    source = 'ip';\n    \n    // Update settings with CF location\n    await db\n      .prepare(`\n        INSERT OR REPLACE INTO user_settings (id, base_lat, base_lng, last_geo_source, updated_at)\n        VALUES (1, ?, ?, 'ip', datetime('now'))\n      `)\n      .bind(lat, lng)\n      .run();\n  } else {\n    // Fall back to defaults from env\n    lat = parseFloat(env.DEFAULT_LAT);\n    lng = parseFloat(env.DEFAULT_LNG);\n    source = 'default';\n  }\n  \n  // 2. Get sun windows for today and tomorrow\n  const today = new Date().toISOString().split('T')[0];\n  const tomorrow = new Date(Date.now() + 86400000).toISOString().split('T')[0];\n  \n  const sunWindowToday = await db\n    .prepare('SELECT * FROM sun_windows WHERE date = ? ORDER BY id DESC LIMIT 1')\n    .bind(today)\n    .first<SunWindow>();\n    \n  const sunWindowTomorrow = await db\n    .prepare('SELECT * FROM sun_windows WHERE date = ? ORDER BY id DESC LIMIT 1')\n    .bind(tomorrow)\n    .first<SunWindow>();\n  \n  // 3. Get weather slots for next 48 hours\n  const now = new Date().toISOString();\n  const in48hours = new Date(Date.now() + 48 * 3600000).toISOString();\n  \n  const weatherSlots = await db\n    .prepare(`\n      SELECT * FROM weather_slots \n      WHERE date_time >= ? AND date_time <= ?\n      ORDER BY date_time ASC\n      LIMIT 48\n    `)\n    .bind(now, in48hours)\n    .all<WeatherSlot>();\n  \n  // Find current weather (closest to now)\n  const currentWeather = weatherSlots.results?.[0] || null;\n  \n  // Calculate average photo day score\n  const photoDayScore = weatherSlots.results?.length\n    ? Math.round(\n        weatherSlots.results.reduce((sum, w) => sum + (w.photoday_score || 50), 0) /\n          weatherSlots.results.length\n      )\n    : 50;\n  \n  // 4. Get places with distance from user location\n  const places = await db\n    .prepare('SELECT * FROM places ORDER BY last_seen_at DESC LIMIT 20')\n    .all<Place>();\n  \n  const placesWithDistance: PlaceWithDistance[] = (places.results || []).map(place => ({\n    ...place,\n    distance_km: haversineDistance(lat, lng, place.lat, place.lng),\n  })).sort((a, b) => a.distance_km - b.distance_km);\n  \n  // 5. Get upcoming task windows with task details\n  const taskWindows = await db\n    .prepare(`\n      SELECT tw.*, t.title as task_title, t.notes as task_notes\n      FROM task_windows tw\n      JOIN tasks t ON tw.task_id = t.task_id\n      WHERE tw.window_start >= ?\n      ORDER BY tw.window_start ASC, tw.score DESC\n      LIMIT 10\n    `)\n    .bind(now)\n    .all<TaskWindowWithTask>();\n  \n  // 6. Get latest YouTube videos\n  const videos = await db\n    .prepare(`\n      SELECT * FROM youtube_videos \n      ORDER BY published_at DESC \n      LIMIT 12\n    `)\n    .all<YouTubeVideo>();\n  \n  return {\n    location: { lat, lng, source },\n    sunWindows: {\n      today: sunWindowToday || null,\n      tomorrow: sunWindowTomorrow || null,\n    },\n    weather: {\n      current: currentWeather,\n      hourly: weatherSlots.results || [],\n      photoDayScore,\n    },\n    places: placesWithDistance,\n    taskWindows: taskWindows.results || [],\n    videos: videos.results || [],\n  };\n}\n", "import { Env, SetLocationRequest } from '../types';\n\n/**\n * POST /api/set-location\n * \n * Updates the user's base location in user_settings.\n * Called when user clicks \"Use precise location\" or enters a manual address.\n * \n * Body: { lat: number, lng: number, source: \"browser\" | \"manual\" }\n */\nexport async function handleSetLocation(\n  env: Env,\n  body: unknown\n): Promise<{ success: boolean; location: { lat: number; lng: number; source: string } }> {\n  // Validate request body\n  if (!body || typeof body !== 'object') {\n    throw new Error('Invalid request body');\n  }\n  \n  const request = body as SetLocationRequest;\n  \n  if (typeof request.lat !== 'number' || typeof request.lng !== 'number') {\n    throw new Error('lat and lng must be numbers');\n  }\n  \n  if (request.lat < -90 || request.lat > 90) {\n    throw new Error('lat must be between -90 and 90');\n  }\n  \n  if (request.lng < -180 || request.lng > 180) {\n    throw new Error('lng must be between -180 and 180');\n  }\n  \n  const source = request.source === 'browser' || request.source === 'manual' \n    ? request.source \n    : 'manual';\n  \n  // Update user_settings\n  await env.DB\n    .prepare(`\n      INSERT OR REPLACE INTO user_settings (id, base_lat, base_lng, last_geo_source, updated_at)\n      VALUES (1, ?, ?, ?, datetime('now'))\n    `)\n    .bind(request.lat, request.lng, source)\n    .run();\n  \n  return {\n    success: true,\n    location: {\n      lat: request.lat,\n      lng: request.lng,\n      source,\n    },\n  };\n}\n", "import { Env, MyPlace } from '../types';\r\n\r\n/**\r\n * Google Sheets API Integration\r\n * \r\n * Read places from Google Sheet and write pinned places back.\r\n * Uses Service Account authentication.\r\n */\r\n\r\n// JWT Header for Google API auth\r\nconst JWT_HEADER = {\r\n    alg: 'RS256',\r\n    typ: 'JWT',\r\n};\r\n\r\n/**\r\n * Create a signed JWT for Google API authentication\r\n */\r\nasync function createJWT(env: Env): Promise<string> {\r\n    const email = env.GOOGLE_SERVICE_ACCOUNT_EMAIL;\r\n    const privateKey = env.GOOGLE_SERVICE_ACCOUNT_PRIVATE_KEY;\r\n\r\n    if (!email || !privateKey) {\r\n        throw new Error('Google Service Account credentials not configured');\r\n    }\r\n\r\n    const now = Math.floor(Date.now() / 1000);\r\n    const expiry = now + 3600; // 1 hour\r\n\r\n    const payload = {\r\n        iss: email,\r\n        scope: 'https://www.googleapis.com/auth/spreadsheets',\r\n        aud: 'https://oauth2.googleapis.com/token',\r\n        iat: now,\r\n        exp: expiry,\r\n    };\r\n\r\n    // Encode header and payload\r\n    const encodedHeader = btoa(JSON.stringify(JWT_HEADER)).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\r\n    const encodedPayload = btoa(JSON.stringify(payload)).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\r\n    const signatureInput = `${encodedHeader}.${encodedPayload}`;\r\n\r\n    // Import the private key and sign\r\n    const pemContents = privateKey\r\n        .replace('-----BEGIN PRIVATE KEY-----', '')\r\n        .replace('-----END PRIVATE KEY-----', '')\r\n        .replace(/\\s/g, '');\r\n\r\n    const binaryKey = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));\r\n\r\n    const cryptoKey = await crypto.subtle.importKey(\r\n        'pkcs8',\r\n        binaryKey,\r\n        { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },\r\n        false,\r\n        ['sign']\r\n    );\r\n\r\n    const signature = await crypto.subtle.sign(\r\n        'RSASSA-PKCS1-v1_5',\r\n        cryptoKey,\r\n        new TextEncoder().encode(signatureInput)\r\n    );\r\n\r\n    const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))\r\n        .replace(/=/g, '')\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_');\r\n\r\n    return `${signatureInput}.${encodedSignature}`;\r\n}\r\n\r\n/**\r\n * Get an access token from Google OAuth\r\n */\r\nasync function getAccessToken(env: Env): Promise<string> {\r\n    const jwt = await createJWT(env);\r\n\r\n    const response = await fetch('https://oauth2.googleapis.com/token', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\r\n        body: `grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer&assertion=${jwt}`,\r\n    });\r\n\r\n    if (!response.ok) {\r\n        const error = await response.text();\r\n        throw new Error(`Failed to get access token: ${error}`);\r\n    }\r\n\r\n    const data = await response.json() as { access_token: string };\r\n    return data.access_token;\r\n}\r\n\r\n/**\r\n * Read places from Google Sheet\r\n * Expected columns: name, lat, lng, notes\r\n */\r\nexport async function readPlacesFromSheet(env: Env): Promise<MyPlace[]> {\r\n    const sheetId = env.GOOGLE_SHEET_ID;\r\n    if (!sheetId) {\r\n        console.warn('GOOGLE_SHEET_ID not configured, skipping sheet sync');\r\n        return [];\r\n    }\r\n\r\n    try {\r\n        const accessToken = await getAccessToken(env);\r\n\r\n        // Read all rows from Sheet1, columns A-D (name, lat, lng, notes)\r\n        const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/Sheet1!A:D`;\r\n\r\n        const response = await fetch(url, {\r\n            headers: { Authorization: `Bearer ${accessToken}` },\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.text();\r\n            throw new Error(`Failed to read sheet: ${error}`);\r\n        }\r\n\r\n        const data = await response.json() as { values?: string[][] };\r\n\r\n        if (!data.values || data.values.length < 2) {\r\n            console.log('No data in sheet (or only header row)');\r\n            return [];\r\n        }\r\n\r\n        // Skip header row, parse data rows\r\n        const places: MyPlace[] = [];\r\n        for (let i = 1; i < data.values.length; i++) {\r\n            const row = data.values[i];\r\n            if (row.length >= 3 && row[0] && row[1] && row[2]) {\r\n                const lat = parseFloat(row[1]);\r\n                const lng = parseFloat(row[2]);\r\n\r\n                if (!isNaN(lat) && !isNaN(lng)) {\r\n                    places.push({\r\n                        sheet_row: i + 1, // 1-indexed row number\r\n                        name: row[0].trim(),\r\n                        lat,\r\n                        lng,\r\n                        notes: row[3]?.trim() || null,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        console.log(`Read ${places.length} places from sheet`);\r\n        return places;\r\n    } catch (error) {\r\n        console.error('Error reading from sheet:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * Append a new place to the Google Sheet (when pinning)\r\n */\r\nexport async function appendPlaceToSheet(env: Env, place: MyPlace): Promise<boolean> {\r\n    const sheetId = env.GOOGLE_SHEET_ID;\r\n    if (!sheetId) {\r\n        console.warn('GOOGLE_SHEET_ID not configured, cannot write to sheet');\r\n        return false;\r\n    }\r\n\r\n    try {\r\n        const accessToken = await getAccessToken(env);\r\n\r\n        const url = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}/values/Sheet1!A:D:append?valueInputOption=USER_ENTERED`;\r\n\r\n        const response = await fetch(url, {\r\n            method: 'POST',\r\n            headers: {\r\n                Authorization: `Bearer ${accessToken}`,\r\n                'Content-Type': 'application/json',\r\n            },\r\n            body: JSON.stringify({\r\n                values: [[place.name, place.lat, place.lng, place.notes || '']],\r\n            }),\r\n        });\r\n\r\n        if (!response.ok) {\r\n            const error = await response.text();\r\n            throw new Error(`Failed to append to sheet: ${error}`);\r\n        }\r\n\r\n        console.log(`Appended place \"${place.name}\" to sheet`);\r\n        return true;\r\n    } catch (error) {\r\n        console.error('Error appending to sheet:', error);\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Sync places from Google Sheet to database\r\n */\r\nexport async function syncPlacesFromSheet(env: Env): Promise<number> {\r\n    const places = await readPlacesFromSheet(env);\r\n\r\n    let synced = 0;\r\n    for (const place of places) {\r\n        try {\r\n            await env.DB\r\n                .prepare(`\r\n          INSERT INTO my_places (sheet_row, name, lat, lng, notes, updated_at)\r\n          VALUES (?, ?, ?, ?, ?, datetime('now'))\r\n          ON CONFLICT(lat, lng) DO UPDATE SET\r\n            sheet_row = excluded.sheet_row,\r\n            name = excluded.name,\r\n            notes = excluded.notes,\r\n            updated_at = datetime('now')\r\n        `)\r\n                .bind(place.sheet_row, place.name, place.lat, place.lng, place.notes)\r\n                .run();\r\n            synced++;\r\n        } catch (error) {\r\n            console.error(`Error syncing place \"${place.name}\":`, error);\r\n        }\r\n    }\r\n\r\n    console.log(`Synced ${synced} places from sheet to database`);\r\n    return synced;\r\n}\r\n", "/**\n * Sun Position & Golden/Blue Hour Calculator\n * \n * Golden Hour: When sun is 0\u00B0 to 6\u00B0 above horizon\n * Blue Hour: When sun is 0\u00B0 to 6\u00B0 below horizon\n * \n * We calculate these from sunrise/sunset times using simple approximations.\n * For more accuracy, we'd use a full solar position library, but this is\n * good enough for photography planning.\n */\n\nexport interface SunTimes {\n  sunrise: Date;\n  sunset: Date;\n  goldenMorningStart: Date;\n  goldenMorningEnd: Date;\n  goldenEveningStart: Date;\n  goldenEveningEnd: Date;\n  blueMorningStart: Date;\n  blueMorningEnd: Date;\n  blueEveningStart: Date;\n  blueEveningEnd: Date;\n}\n\n/**\n * Calculate golden and blue hour windows from sunrise/sunset times.\n * \n * Approximations:\n * - Golden hour morning: starts ~20 min before sunrise, ends ~40-60 min after\n * - Golden hour evening: starts ~60 min before sunset, ends ~20 min after\n * - Blue hour: ~30 min window before golden morning / after golden evening\n */\nexport function calculateSunWindows(sunrise: Date, sunset: Date): SunTimes {\n  // Golden hour durations (in minutes)\n  const GOLDEN_BEFORE_SUNRISE = 20;\n  const GOLDEN_AFTER_SUNRISE = 50;\n  const GOLDEN_BEFORE_SUNSET = 60;\n  const GOLDEN_AFTER_SUNSET = 20;\n  \n  // Blue hour: ~30 min before/after golden hours\n  const BLUE_DURATION = 30;\n\n  // Morning golden hour\n  const goldenMorningStart = addMinutes(sunrise, -GOLDEN_BEFORE_SUNRISE);\n  const goldenMorningEnd = addMinutes(sunrise, GOLDEN_AFTER_SUNRISE);\n\n  // Evening golden hour  \n  const goldenEveningStart = addMinutes(sunset, -GOLDEN_BEFORE_SUNSET);\n  const goldenEveningEnd = addMinutes(sunset, GOLDEN_AFTER_SUNSET);\n\n  // Morning blue hour (before golden)\n  const blueMorningStart = addMinutes(goldenMorningStart, -BLUE_DURATION);\n  const blueMorningEnd = goldenMorningStart;\n\n  // Evening blue hour (after golden)\n  const blueEveningStart = goldenEveningEnd;\n  const blueEveningEnd = addMinutes(goldenEveningEnd, BLUE_DURATION);\n\n  return {\n    sunrise,\n    sunset,\n    goldenMorningStart,\n    goldenMorningEnd,\n    goldenEveningStart,\n    goldenEveningEnd,\n    blueMorningStart,\n    blueMorningEnd,\n    blueEveningStart,\n    blueEveningEnd,\n  };\n}\n\n/**\n * Check if a given time falls within a specific window\n */\nexport function isTimeInWindow(time: Date, windowStart: Date, windowEnd: Date): boolean {\n  return time >= windowStart && time <= windowEnd;\n}\n\n/**\n * Check if time is during any golden hour\n */\nexport function isDuringGoldenHour(time: Date, sunTimes: SunTimes): 'morning' | 'evening' | null {\n  if (isTimeInWindow(time, sunTimes.goldenMorningStart, sunTimes.goldenMorningEnd)) {\n    return 'morning';\n  }\n  if (isTimeInWindow(time, sunTimes.goldenEveningStart, sunTimes.goldenEveningEnd)) {\n    return 'evening';\n  }\n  return null;\n}\n\n/**\n * Check if time is during any blue hour\n */\nexport function isDuringBlueHour(time: Date, sunTimes: SunTimes): 'morning' | 'evening' | null {\n  if (isTimeInWindow(time, sunTimes.blueMorningStart, sunTimes.blueMorningEnd)) {\n    return 'morning';\n  }\n  if (isTimeInWindow(time, sunTimes.blueEveningStart, sunTimes.blueEveningEnd)) {\n    return 'evening';\n  }\n  return null;\n}\n\n// Helper: add minutes to a date\nfunction addMinutes(date: Date, minutes: number): Date {\n  return new Date(date.getTime() + minutes * 60 * 1000);\n}\n\n/**\n * Format date to ISO string for storage\n */\nexport function toISOString(date: Date): string {\n  return date.toISOString();\n}\n\n/**\n * Format date to YYYY-MM-DD\n */\nexport function toDateString(date: Date): string {\n  return date.toISOString().split('T')[0];\n}\n\n/**\n * Parse ISO string to Date\n */\nexport function parseISO(isoString: string): Date {\n  return new Date(isoString);\n}\n", "import { Env, MyPlace, DiscoveredPlace, PlaceForecast } from '../types';\r\nimport { syncPlacesFromSheet, appendPlaceToSheet } from '../lib/sheets-sync';\r\nimport { calculateSunWindows, toISOString } from '../lib/sun';\r\n\r\n/**\r\n * Handler: My Places API\r\n * \r\n * Endpoints for managing user's photo locations\r\n */\r\n\r\ninterface ForecastResponse {\r\n    place: MyPlace;\r\n    forecasts: PlaceForecast[];\r\n    nearby: DiscoveredPlace[];\r\n}\r\n\r\n/**\r\n * GET /api/my-places\r\n * List all user places with their 3-day forecasts\r\n */\r\nexport async function handleGetMyPlaces(env: Env): Promise<ForecastResponse[]> {\r\n    // Get all active places\r\n    const places = await env.DB\r\n        .prepare('SELECT * FROM my_places WHERE active = 1 ORDER BY created_at DESC')\r\n        .all<MyPlace>();\r\n\r\n    if (!places.results || places.results.length === 0) {\r\n        return [];\r\n    }\r\n\r\n    const response: ForecastResponse[] = [];\r\n\r\n    for (const place of places.results) {\r\n        // Get 3-day forecast for this place\r\n        const forecasts = await env.DB\r\n            .prepare(`\r\n        SELECT * FROM place_forecasts \r\n        WHERE place_id = ? AND date >= date('now')\r\n        ORDER BY date ASC\r\n        LIMIT 3\r\n      `)\r\n            .bind(place.id)\r\n            .all<PlaceForecast>();\r\n\r\n        // Get nearby discovered places\r\n        const nearby = await env.DB\r\n            .prepare(`\r\n        SELECT * FROM discovered_places \r\n        WHERE near_place_id = ?\r\n        ORDER BY rating DESC, distance_km ASC\r\n        LIMIT 10\r\n      `)\r\n            .bind(place.id)\r\n            .all<DiscoveredPlace>();\r\n\r\n        response.push({\r\n            place,\r\n            forecasts: forecasts.results || [],\r\n            nearby: nearby.results || [],\r\n        });\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\n/**\r\n * POST /api/my-places/sync\r\n * Sync places from Google Sheet\r\n */\r\nexport async function handleSyncFromSheet(env: Env): Promise<{ synced: number }> {\r\n    const synced = await syncPlacesFromSheet(env);\r\n    return { synced };\r\n}\r\n\r\n/**\r\n * POST /api/my-places/:id/check-now\r\n * Immediately fetch weather for a specific place\r\n */\r\nexport async function handleCheckNow(env: Env, placeId: number): Promise<PlaceForecast[]> {\r\n    // Get the place\r\n    const place = await env.DB\r\n        .prepare('SELECT * FROM my_places WHERE id = ?')\r\n        .bind(placeId)\r\n        .first<MyPlace>();\r\n\r\n    if (!place) {\r\n        throw new Error('Place not found');\r\n    }\r\n\r\n    // Fetch 3-day weather from Open-Meteo\r\n    const url = new URL('https://api.open-meteo.com/v1/forecast');\r\n    url.searchParams.set('latitude', place.lat.toString());\r\n    url.searchParams.set('longitude', place.lng.toString());\r\n    url.searchParams.set('hourly', 'cloudcover');\r\n    url.searchParams.set('daily', 'sunrise,sunset');\r\n    url.searchParams.set('timezone', 'auto');\r\n    url.searchParams.set('forecast_days', '3');\r\n\r\n    const response = await fetch(url.toString());\r\n    if (!response.ok) {\r\n        throw new Error('Failed to fetch weather');\r\n    }\r\n\r\n    interface OpenMeteoResponse {\r\n        daily: {\r\n            time: string[];\r\n            sunrise: string[];\r\n            sunset: string[];\r\n        };\r\n        hourly: {\r\n            time: string[];\r\n            cloudcover: number[];\r\n        };\r\n    }\r\n\r\n    const data = (await response.json()) as OpenMeteoResponse;\r\n    const forecasts: PlaceForecast[] = [];\r\n\r\n    // Process each day\r\n    for (let i = 0; i < data.daily.time.length; i++) {\r\n        const date = data.daily.time[i];\r\n        const sunrise = new Date(data.daily.sunrise[i]);\r\n        const sunset = new Date(data.daily.sunset[i]);\r\n        const sunTimes = calculateSunWindows(sunrise, sunset);\r\n\r\n        // Find cloud cover during golden hours\r\n        const goldenMorningHour = sunrise.getHours();\r\n        const goldenEveningHour = sunset.getHours();\r\n\r\n        // Find the hourly index for morning and evening\r\n        const dayStart = i * 24;\r\n        const morningClouds = data.hourly.cloudcover[dayStart + goldenMorningHour] || 50;\r\n        const eveningClouds = data.hourly.cloudcover[dayStart + goldenEveningHour] || 50;\r\n\r\n        const forecast: PlaceForecast = {\r\n            place_id: placeId,\r\n            date,\r\n            sunrise: toISOString(sunrise),\r\n            sunset: toISOString(sunset),\r\n            golden_morning_start: toISOString(sunTimes.goldenMorningStart),\r\n            golden_morning_end: toISOString(sunTimes.goldenMorningEnd),\r\n            golden_evening_start: toISOString(sunTimes.goldenEveningStart),\r\n            golden_evening_end: toISOString(sunTimes.goldenEveningEnd),\r\n            blue_morning_start: toISOString(sunTimes.blueMorningStart),\r\n            blue_morning_end: toISOString(sunTimes.blueMorningEnd),\r\n            blue_evening_start: toISOString(sunTimes.blueEveningStart),\r\n            blue_evening_end: toISOString(sunTimes.blueEveningEnd),\r\n            morning_clouds: morningClouds,\r\n            evening_clouds: eveningClouds,\r\n            sky_open_morning: morningClouds < 30 ? 1 : 0,\r\n            sky_open_evening: eveningClouds < 30 ? 1 : 0,\r\n        };\r\n\r\n        // Upsert to database\r\n        await env.DB\r\n            .prepare(`\r\n        INSERT INTO place_forecasts (\r\n          place_id, date, sunrise, sunset,\r\n          golden_morning_start, golden_morning_end,\r\n          golden_evening_start, golden_evening_end,\r\n          blue_morning_start, blue_morning_end,\r\n          blue_evening_start, blue_evening_end,\r\n          morning_clouds, evening_clouds,\r\n          sky_open_morning, sky_open_evening,\r\n          updated_at\r\n        )\r\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))\r\n        ON CONFLICT(place_id, date) DO UPDATE SET\r\n          sunrise = excluded.sunrise,\r\n          sunset = excluded.sunset,\r\n          golden_morning_start = excluded.golden_morning_start,\r\n          golden_morning_end = excluded.golden_morning_end,\r\n          golden_evening_start = excluded.golden_evening_start,\r\n          golden_evening_end = excluded.golden_evening_end,\r\n          blue_morning_start = excluded.blue_morning_start,\r\n          blue_morning_end = excluded.blue_morning_end,\r\n          blue_evening_start = excluded.blue_evening_start,\r\n          blue_evening_end = excluded.blue_evening_end,\r\n          morning_clouds = excluded.morning_clouds,\r\n          evening_clouds = excluded.evening_clouds,\r\n          sky_open_morning = excluded.sky_open_morning,\r\n          sky_open_evening = excluded.sky_open_evening,\r\n          updated_at = datetime('now')\r\n      `)\r\n            .bind(\r\n                forecast.place_id, forecast.date,\r\n                forecast.sunrise, forecast.sunset,\r\n                forecast.golden_morning_start, forecast.golden_morning_end,\r\n                forecast.golden_evening_start, forecast.golden_evening_end,\r\n                forecast.blue_morning_start, forecast.blue_morning_end,\r\n                forecast.blue_evening_start, forecast.blue_evening_end,\r\n                forecast.morning_clouds, forecast.evening_clouds,\r\n                forecast.sky_open_morning, forecast.sky_open_evening\r\n            )\r\n            .run();\r\n\r\n        forecasts.push(forecast);\r\n    }\r\n\r\n    return forecasts;\r\n}\r\n\r\n/**\r\n * GET /api/my-places/:id/nearby\r\n * Get discovered places near a user location\r\n */\r\nexport async function handleGetNearby(env: Env, placeId: number): Promise<DiscoveredPlace[]> {\r\n    const nearby = await env.DB\r\n        .prepare(`\r\n      SELECT * FROM discovered_places \r\n      WHERE near_place_id = ?\r\n      ORDER BY rating DESC, distance_km ASC\r\n      LIMIT 20\r\n    `)\r\n        .bind(placeId)\r\n        .all<DiscoveredPlace>();\r\n\r\n    return nearby.results || [];\r\n}\r\n\r\n/**\r\n * POST /api/discovered/:id/pin\r\n * Pin a discovered place (adds to Google Sheet)\r\n */\r\nexport async function handlePinPlace(env: Env, discoveredId: number): Promise<{ success: boolean; place?: MyPlace }> {\r\n    // Get the discovered place\r\n    const discovered = await env.DB\r\n        .prepare('SELECT * FROM discovered_places WHERE id = ?')\r\n        .bind(discoveredId)\r\n        .first<DiscoveredPlace>();\r\n\r\n    if (!discovered) {\r\n        throw new Error('Discovered place not found');\r\n    }\r\n\r\n    // Check if already pinned\r\n    if (discovered.is_pinned) {\r\n        return { success: true };\r\n    }\r\n\r\n    // Create new place from discovered\r\n    const newPlace: MyPlace = {\r\n        name: discovered.name,\r\n        lat: discovered.lat,\r\n        lng: discovered.lng,\r\n        notes: `Pinned from Google Places (rating: ${discovered.rating || 'N/A'})`,\r\n        pinned_from: discovered.google_place_id,\r\n    };\r\n\r\n    // Add to Google Sheet\r\n    const sheetSuccess = await appendPlaceToSheet(env, newPlace);\r\n\r\n    // Insert into my_places\r\n    const result = await env.DB\r\n        .prepare(`\r\n      INSERT INTO my_places (name, lat, lng, notes, pinned_from, created_at, updated_at)\r\n      VALUES (?, ?, ?, ?, ?, datetime('now'), datetime('now'))\r\n      ON CONFLICT(lat, lng) DO UPDATE SET\r\n        name = excluded.name,\r\n        updated_at = datetime('now')\r\n    `)\r\n        .bind(newPlace.name, newPlace.lat, newPlace.lng, newPlace.notes, newPlace.pinned_from)\r\n        .run();\r\n\r\n    // Mark as pinned\r\n    await env.DB\r\n        .prepare('UPDATE discovered_places SET is_pinned = 1 WHERE id = ?')\r\n        .bind(discoveredId)\r\n        .run();\r\n\r\n    // Get the inserted place\r\n    const insertedPlace = await env.DB\r\n        .prepare('SELECT * FROM my_places WHERE lat = ? AND lng = ?')\r\n        .bind(newPlace.lat, newPlace.lng)\r\n        .first<MyPlace>();\r\n\r\n    return { success: true, place: insertedPlace || undefined };\r\n}\r\n", "/**\n * Weather Scoring for Photography\n * \n * Calculates a \"Photo Day Score\" (0-100) based on weather conditions.\n * Different conditions are good for different types of photography.\n */\n\nexport interface WeatherConditions {\n  clouds: number;      // Cloud cover 0-100%\n  precip: number;      // Precipitation mm/h\n  visibility: number;  // Visibility in km\n  temp: number;        // Temperature in Celsius\n}\n\n/**\n * Calculate overall Photo Day Score (0-100)\n * \n * Scoring logic:\n * - Clear skies (low clouds) are generally best for golden hour\n * - Some clouds (20-40%) can add drama\n * - Heavy clouds reduce score but can be good for portraits\n * - Rain/precipitation significantly reduces score\n * - Low visibility (fog) can be interesting but scores lower\n * - Extreme temperatures slightly reduce score\n */\nexport function calculatePhotoDayScore(conditions: WeatherConditions): number {\n  let score = 100;\n  \n  // Cloud cover scoring\n  // 0-20%: excellent (clear golden hour)\n  // 20-40%: great (some drama)\n  // 40-60%: okay (diffused light)\n  // 60-80%: mediocre\n  // 80-100%: poor for most outdoor\n  if (conditions.clouds <= 20) {\n    score -= 0;\n  } else if (conditions.clouds <= 40) {\n    score -= 5;\n  } else if (conditions.clouds <= 60) {\n    score -= 15;\n  } else if (conditions.clouds <= 80) {\n    score -= 30;\n  } else {\n    score -= 45;\n  }\n  \n  // Precipitation penalty\n  // Any precipitation significantly impacts outdoor photography\n  if (conditions.precip > 0 && conditions.precip <= 0.5) {\n    score -= 20; // Light drizzle\n  } else if (conditions.precip > 0.5 && conditions.precip <= 2) {\n    score -= 35; // Moderate rain\n  } else if (conditions.precip > 2) {\n    score -= 50; // Heavy rain\n  }\n  \n  // Visibility scoring\n  // High visibility is important for landscapes\n  if (conditions.visibility >= 20) {\n    score -= 0;  // Excellent\n  } else if (conditions.visibility >= 10) {\n    score -= 5;  // Good\n  } else if (conditions.visibility >= 5) {\n    score -= 10; // Okay\n  } else if (conditions.visibility >= 1) {\n    score -= 15; // Fog - can be artistic!\n  } else {\n    score -= 25; // Very poor\n  }\n  \n  // Temperature comfort (minor factor)\n  // Photographers need to be comfortable!\n  if (conditions.temp >= 10 && conditions.temp <= 25) {\n    score -= 0;  // Comfortable\n  } else if (conditions.temp >= 0 && conditions.temp < 10) {\n    score -= 3;  // Cold but manageable\n  } else if (conditions.temp > 25 && conditions.temp <= 35) {\n    score -= 3;  // Hot but manageable\n  } else {\n    score -= 8;  // Extreme temps\n  }\n  \n  return Math.max(0, Math.min(100, Math.round(score)));\n}\n\n/**\n * Get a human-readable description of conditions\n */\nexport function describeConditions(conditions: WeatherConditions): string {\n  const parts: string[] = [];\n  \n  // Cloud description\n  if (conditions.clouds <= 10) {\n    parts.push('clear skies');\n  } else if (conditions.clouds <= 30) {\n    parts.push('few clouds');\n  } else if (conditions.clouds <= 60) {\n    parts.push('partly cloudy');\n  } else if (conditions.clouds <= 85) {\n    parts.push('mostly cloudy');\n  } else {\n    parts.push('overcast');\n  }\n  \n  // Precipitation\n  if (conditions.precip > 2) {\n    parts.push('heavy rain');\n  } else if (conditions.precip > 0.5) {\n    parts.push('rain');\n  } else if (conditions.precip > 0) {\n    parts.push('light drizzle');\n  }\n  \n  // Visibility (only mention if notable)\n  if (conditions.visibility < 1) {\n    parts.push('dense fog');\n  } else if (conditions.visibility < 5) {\n    parts.push('foggy');\n  } else if (conditions.visibility < 10) {\n    parts.push('misty');\n  }\n  \n  return parts.join(', ') || 'normal conditions';\n}\n\n/**\n * Check if conditions match a specific task condition requirement\n */\nexport function conditionsMatch(\n  conditions: WeatherConditions,\n  requirement: string\n): { matches: boolean; reason: string } {\n  switch (requirement) {\n    case 'clear-any':\n    case 'clear-noon':\n      if (conditions.clouds <= 30 && conditions.precip === 0) {\n        return { matches: true, reason: 'Clear skies with low cloud cover' };\n      }\n      return { matches: false, reason: 'Too cloudy or precipitation expected' };\n      \n    case 'overcast':\n      if (conditions.clouds >= 70 && conditions.precip < 0.5) {\n        return { matches: true, reason: 'Overcast skies, good for portraits' };\n      }\n      return { matches: false, reason: 'Not enough cloud cover' };\n      \n    case 'cloudy':\n      if (conditions.clouds >= 40 && conditions.precip < 0.5) {\n        return { matches: true, reason: 'Cloudy conditions for soft light' };\n      }\n      return { matches: false, reason: 'Conditions too clear or rainy' };\n      \n    case 'fog':\n      if (conditions.visibility < 5 && conditions.precip < 0.5) {\n        return { matches: true, reason: 'Foggy/misty conditions' };\n      }\n      return { matches: false, reason: 'No fog or mist present' };\n      \n    case 'golden-hour-morning':\n    case 'golden-hour-evening':\n    case 'golden-hour-any':\n    case 'blue-hour-morning':\n    case 'blue-hour-evening':\n      // These are time-based, but weather still matters\n      // Low clouds and no precipitation preferred\n      if (conditions.clouds <= 50 && conditions.precip === 0) {\n        return { matches: true, reason: 'Good conditions for golden/blue hour' };\n      }\n      return { matches: false, reason: 'Weather may obscure golden/blue hour effect' };\n      \n    case 'any':\n    default:\n      return { matches: true, reason: 'Any weather conditions acceptable' };\n  }\n}\n", "import { Env, UserSettings, GooglePlacesResponse, OpenMeteoResponse } from '../types';\nimport { calculateSunWindows, toISOString, toDateString } from '../lib/sun';\nimport { calculatePhotoDayScore } from '../lib/weather-score';\n\n/**\n * Cron: places-and-weather\n * \n * Runs every hour to:\n * 1. Fetch interesting photo locations from Google Places API\n * 2. Fetch weather forecast from Open-Meteo\n * 3. Calculate and store sun windows (golden/blue hour)\n */\nexport async function runPlacesAndWeatherSync(env: Env): Promise<void> {\n  // Get base location from settings\n  const settings = await env.DB\n    .prepare('SELECT * FROM user_settings WHERE id = 1')\n    .first<UserSettings>();\n  \n  const lat = settings?.base_lat || parseFloat(env.DEFAULT_LAT);\n  const lng = settings?.base_lng || parseFloat(env.DEFAULT_LNG);\n  const radiusKm = parseFloat(env.DEFAULT_RADIUS_KM) || 30;\n  \n  console.log(`Syncing places and weather for: ${lat}, ${lng} (radius: ${radiusKm}km)`);\n  \n  // Run syncs in parallel\n  await Promise.all([\n    syncPlaces(env, lat, lng, radiusKm),\n    syncWeatherAndSun(env, lat, lng),\n  ]);\n}\n\n/**\n * Sync places from Google Places API (New)\n */\nasync function syncPlaces(env: Env, lat: number, lng: number, radiusKm: number): Promise<void> {\n  const apiKey = env.GOOGLE_PLACES_API_KEY;\n  if (!apiKey) {\n    console.warn('GOOGLE_PLACES_API_KEY not set, skipping places sync');\n    return;\n  }\n  \n  // Place types interesting for photography\n  const includedTypes = [\n    'park',\n    'natural_feature', \n    'tourist_attraction',\n    'point_of_interest',\n    'establishment',\n  ];\n  \n  // Google Places API (New) - Nearby Search\n  // https://developers.google.com/maps/documentation/places/web-service/nearby-search\n  const response = await fetch(\n    'https://places.googleapis.com/v1/places:searchNearby',\n    {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Goog-Api-Key': apiKey,\n        'X-Goog-FieldMask': 'places.id,places.displayName,places.location,places.types,places.rating,places.photos',\n      },\n      body: JSON.stringify({\n        locationRestriction: {\n          circle: {\n            center: { latitude: lat, longitude: lng },\n            radius: radiusKm * 1000, // Convert to meters\n          },\n        },\n        includedTypes,\n        maxResultCount: 20,\n      }),\n    }\n  );\n  \n  if (!response.ok) {\n    const error = await response.text();\n    console.error('Google Places API error:', error);\n    return;\n  }\n  \n  const data = (await response.json()) as GooglePlacesResponse;\n  \n  if (!data.places || data.places.length === 0) {\n    console.log('No places found');\n    return;\n  }\n  \n  // Upsert places into database\n  for (const place of data.places) {\n    const photoReference = place.photos?.[0]?.name || null;\n    \n    // If we have a photo reference, construct the photo URL\n    let photoUrl: string | null = null;\n    if (photoReference) {\n      // Photo URL via Places API (New)\n      // Format: https://places.googleapis.com/v1/{photo_name}/media?maxWidthPx=400&key=API_KEY\n      photoUrl = `https://places.googleapis.com/v1/${photoReference}/media?maxWidthPx=800&key=${apiKey}`;\n    }\n    \n    await env.DB\n      .prepare(`\n        INSERT INTO places (place_id, name, lat, lng, types, rating, photo_reference, photo_url, last_seen_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))\n        ON CONFLICT(place_id) DO UPDATE SET\n          name = excluded.name,\n          types = excluded.types,\n          rating = excluded.rating,\n          photo_reference = excluded.photo_reference,\n          photo_url = excluded.photo_url,\n          last_seen_at = datetime('now')\n      `)\n      .bind(\n        place.id,\n        place.displayName.text,\n        place.location.latitude,\n        place.location.longitude,\n        JSON.stringify(place.types),\n        place.rating || null,\n        photoReference,\n        photoUrl\n      )\n      .run();\n  }\n  \n  console.log(`Synced ${data.places.length} places`);\n}\n\n/**\n * Sync weather forecast and calculate sun windows\n * Using Open-Meteo API (free, no API key required)\n */\nasync function syncWeatherAndSun(env: Env, lat: number, lng: number): Promise<void> {\n  // Open-Meteo API - free weather API\n  // https://open-meteo.com/en/docs\n  const url = new URL('https://api.open-meteo.com/v1/forecast');\n  url.searchParams.set('latitude', lat.toString());\n  url.searchParams.set('longitude', lng.toString());\n  url.searchParams.set('hourly', 'temperature_2m,cloudcover,precipitation,visibility');\n  url.searchParams.set('daily', 'sunrise,sunset');\n  url.searchParams.set('timezone', 'auto');\n  url.searchParams.set('forecast_days', '3');\n  \n  const response = await fetch(url.toString());\n  \n  if (!response.ok) {\n    console.error('Open-Meteo API error:', await response.text());\n    return;\n  }\n  \n  const data = (await response.json()) as OpenMeteoResponse;\n  \n  // Store hourly weather slots\n  const hourlyTimes = data.hourly.time;\n  for (let i = 0; i < hourlyTimes.length; i++) {\n    const conditions = {\n      clouds: data.hourly.cloudcover[i],\n      precip: data.hourly.precipitation[i],\n      visibility: data.hourly.visibility[i] / 1000, // Convert m to km\n      temp: data.hourly.temperature_2m[i],\n    };\n    \n    const score = calculatePhotoDayScore(conditions);\n    \n    await env.DB\n      .prepare(`\n        INSERT INTO weather_slots (date_time, lat, lng, clouds, precip, visibility, temp, photoday_score)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        ON CONFLICT(date_time, lat, lng) DO UPDATE SET\n          clouds = excluded.clouds,\n          precip = excluded.precip,\n          visibility = excluded.visibility,\n          temp = excluded.temp,\n          photoday_score = excluded.photoday_score\n      `)\n      .bind(\n        new Date(hourlyTimes[i]).toISOString(),\n        lat,\n        lng,\n        conditions.clouds,\n        conditions.precip,\n        conditions.visibility,\n        conditions.temp,\n        score\n      )\n      .run();\n  }\n  \n  console.log(`Synced ${hourlyTimes.length} weather slots`);\n  \n  // Store sun windows (sunrise/sunset + calculated golden/blue hours)\n  const dailyTimes = data.daily.time;\n  for (let i = 0; i < dailyTimes.length; i++) {\n    const sunrise = new Date(data.daily.sunrise[i]);\n    const sunset = new Date(data.daily.sunset[i]);\n    const sunTimes = calculateSunWindows(sunrise, sunset);\n    \n    await env.DB\n      .prepare(`\n        INSERT INTO sun_windows (\n          date, lat, lng, sunrise, sunset,\n          golden_morning_start, golden_morning_end,\n          golden_evening_start, golden_evening_end,\n          blue_morning_start, blue_morning_end,\n          blue_evening_start, blue_evening_end\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        ON CONFLICT(date, lat, lng) DO UPDATE SET\n          sunrise = excluded.sunrise,\n          sunset = excluded.sunset,\n          golden_morning_start = excluded.golden_morning_start,\n          golden_morning_end = excluded.golden_morning_end,\n          golden_evening_start = excluded.golden_evening_start,\n          golden_evening_end = excluded.golden_evening_end,\n          blue_morning_start = excluded.blue_morning_start,\n          blue_morning_end = excluded.blue_morning_end,\n          blue_evening_start = excluded.blue_evening_start,\n          blue_evening_end = excluded.blue_evening_end\n      `)\n      .bind(\n        dailyTimes[i],\n        lat,\n        lng,\n        toISOString(sunrise),\n        toISOString(sunset),\n        toISOString(sunTimes.goldenMorningStart),\n        toISOString(sunTimes.goldenMorningEnd),\n        toISOString(sunTimes.goldenEveningStart),\n        toISOString(sunTimes.goldenEveningEnd),\n        toISOString(sunTimes.blueMorningStart),\n        toISOString(sunTimes.blueMorningEnd),\n        toISOString(sunTimes.blueEveningStart),\n        toISOString(sunTimes.blueEveningEnd)\n      )\n      .run();\n  }\n  \n  console.log(`Synced ${dailyTimes.length} sun windows`);\n}\n", "import { Env, YouTubeSearchResponse } from '../types';\n\n/**\n * Cron: youtube-sync\n * \n * Runs every hour to:\n * 1. Fetch latest videos from configured photography channels\n * 2. Upsert into youtube_videos table\n */\nexport async function runYouTubeSync(env: Env): Promise<void> {\n  const apiKey = env.YOUTUBE_API_KEY;\n  \n  if (!apiKey) {\n    console.warn('YOUTUBE_API_KEY not set, skipping YouTube sync');\n    return;\n  }\n  \n  // Get channel IDs from environment (comma-separated)\n  const channelIds = env.YOUTUBE_CHANNELS?.split(',').map(id => id.trim()).filter(Boolean) || [];\n  \n  if (channelIds.length === 0) {\n    console.log('No YouTube channels configured');\n    return;\n  }\n  \n  console.log(`Syncing videos from ${channelIds.length} channels...`);\n  \n  let totalSynced = 0;\n  \n  for (const channelId of channelIds) {\n    try {\n      const count = await syncChannelVideos(env, apiKey, channelId);\n      totalSynced += count;\n    } catch (error) {\n      console.error(`Error syncing channel ${channelId}:`, error);\n    }\n  }\n  \n  console.log(`Synced ${totalSynced} videos total`);\n}\n\n/**\n * Sync videos from a single YouTube channel\n */\nasync function syncChannelVideos(\n  env: Env,\n  apiKey: string,\n  channelId: string\n): Promise<number> {\n  // YouTube Data API v3 - Search\n  // https://developers.google.com/youtube/v3/docs/search/list\n  const url = new URL('https://www.googleapis.com/youtube/v3/search');\n  url.searchParams.set('key', apiKey);\n  url.searchParams.set('channelId', channelId);\n  url.searchParams.set('part', 'snippet');\n  url.searchParams.set('type', 'video');\n  url.searchParams.set('order', 'date');\n  url.searchParams.set('maxResults', '10'); // Get latest 10 videos per channel\n  \n  const response = await fetch(url.toString());\n  \n  if (!response.ok) {\n    const error = await response.text();\n    throw new Error(`YouTube API error: ${error}`);\n  }\n  \n  const data = (await response.json()) as YouTubeSearchResponse;\n  \n  if (!data.items || data.items.length === 0) {\n    return 0;\n  }\n  \n  for (const item of data.items) {\n    const videoId = item.id.videoId;\n    const snippet = item.snippet;\n    \n    await env.DB\n      .prepare(`\n        INSERT INTO youtube_videos (\n          channel_id, video_id, title, description, published_at,\n          thumbnail_url, url, last_seen_at\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))\n        ON CONFLICT(video_id) DO UPDATE SET\n          title = excluded.title,\n          description = excluded.description,\n          thumbnail_url = excluded.thumbnail_url,\n          last_seen_at = datetime('now')\n      `)\n      .bind(\n        snippet.channelId,\n        videoId,\n        snippet.title,\n        snippet.description?.substring(0, 500) || null, // Truncate long descriptions\n        snippet.publishedAt,\n        snippet.thumbnails?.medium?.url || snippet.thumbnails?.default?.url || null,\n        `https://www.youtube.com/watch?v=${videoId}`\n      )\n      .run();\n  }\n  \n  return data.items.length;\n}\n", "import { Env } from './types';\nimport { handleDashboard } from './handlers/dashboard';\nimport { handleSetLocation } from './handlers/set-location';\nimport {\n  handleGetMyPlaces,\n  handleSyncFromSheet,\n  handleCheckNow,\n  handleGetNearby,\n  handlePinPlace,\n} from './handlers/my-places';\nimport { runPlacesAndWeatherSync } from './cron/places-and-weather';\nimport { runYouTubeSync } from './cron/youtube-sync';\nimport { syncPlacesFromSheet } from './lib/sheets-sync';\n\n// =============================================================================\n// CORS Headers - Allow frontend to call our API\n// =============================================================================\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Methods': 'GET, POST, DELETE, OPTIONS',\n  'Access-Control-Allow-Headers': 'Content-Type',\n};\n\nfunction handleCors(request: Request): Response | null {\n  if (request.method === 'OPTIONS') {\n    return new Response(null, { headers: corsHeaders });\n  }\n  return null;\n}\n\nfunction jsonResponse(data: unknown, status = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: {\n      'Content-Type': 'application/json',\n      ...corsHeaders,\n    },\n  });\n}\n\nfunction errorResponse(message: string, status = 500): Response {\n  return jsonResponse({ error: message }, status);\n}\n\n// Helper to extract ID from path like /api/my-places/123/check-now\nfunction extractId(path: string, pattern: RegExp): number | null {\n  const match = path.match(pattern);\n  return match ? parseInt(match[1], 10) : null;\n}\n\n// =============================================================================\n// Main Worker Export\n// =============================================================================\nexport default {\n  /**\n   * HTTP Request Handler\n   * Routes incoming requests to appropriate handlers\n   */\n  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n    // Handle CORS preflight\n    const corsResponse = handleCors(request);\n    if (corsResponse) return corsResponse;\n\n    const url = new URL(request.url);\n    const path = url.pathname;\n\n    try {\n      // =======================================================================\n      // Dashboard Routes (existing)\n      // =======================================================================\n\n      // Route: GET /api/dashboard\n      if (path === '/api/dashboard' && request.method === 'GET') {\n        const lat = url.searchParams.get('lat')\n          ? parseFloat(url.searchParams.get('lat')!)\n          : (request.cf?.latitude as number | undefined);\n        const lng = url.searchParams.get('lng')\n          ? parseFloat(url.searchParams.get('lng')!)\n          : (request.cf?.longitude as number | undefined);\n\n        const data = await handleDashboard(env, lat, lng);\n        return jsonResponse(data);\n      }\n\n      // Route: POST /api/set-location\n      if (path === '/api/set-location' && request.method === 'POST') {\n        const body = await request.json();\n        const result = await handleSetLocation(env, body);\n        return jsonResponse(result);\n      }\n\n      // =======================================================================\n      // My Places Routes (new)\n      // =======================================================================\n\n      // Route: GET /api/my-places - List all places with forecasts\n      if (path === '/api/my-places' && request.method === 'GET') {\n        const data = await handleGetMyPlaces(env);\n        return jsonResponse(data);\n      }\n\n      // Route: POST /api/my-places/sync - Sync from Google Sheet\n      if (path === '/api/my-places/sync' && request.method === 'POST') {\n        const result = await handleSyncFromSheet(env);\n        return jsonResponse(result);\n      }\n\n      // Route: POST /api/my-places/:id/check-now - Immediate weather check\n      const checkNowMatch = path.match(/^\\/api\\/my-places\\/(\\d+)\\/check-now$/);\n      if (checkNowMatch && request.method === 'POST') {\n        const placeId = parseInt(checkNowMatch[1], 10);\n        const forecasts = await handleCheckNow(env, placeId);\n        return jsonResponse({ forecasts });\n      }\n\n      // Route: GET /api/my-places/:id/nearby - Get nearby discovered places\n      const nearbyMatch = path.match(/^\\/api\\/my-places\\/(\\d+)\\/nearby$/);\n      if (nearbyMatch && request.method === 'GET') {\n        const placeId = parseInt(nearbyMatch[1], 10);\n        const nearby = await handleGetNearby(env, placeId);\n        return jsonResponse({ nearby });\n      }\n\n      // Route: POST /api/discovered/:id/pin - Pin a discovered place\n      const pinMatch = path.match(/^\\/api\\/discovered\\/(\\d+)\\/pin$/);\n      if (pinMatch && request.method === 'POST') {\n        const discoveredId = parseInt(pinMatch[1], 10);\n        const result = await handlePinPlace(env, discoveredId);\n        return jsonResponse(result);\n      }\n\n      // =======================================================================\n      // Utility Routes\n      // =======================================================================\n\n      // Route: GET /api/videos - Get YouTube videos\n      if (path === '/api/videos' && request.method === 'GET') {\n        const videos = await env.DB\n          .prepare('SELECT * FROM youtube_videos ORDER BY published_at DESC LIMIT 20')\n          .all();\n        return jsonResponse({ videos: videos.results || [] });\n      }\n\n      // Route: GET /api/health - Health check\n      if (path === '/api/health') {\n        return jsonResponse({ status: 'ok', timestamp: new Date().toISOString() });\n      }\n\n      // 404 for unknown routes\n      return errorResponse('Not found', 404);\n\n    } catch (error) {\n      console.error('Request error:', error);\n      const message = error instanceof Error ? error.message : 'Internal server error';\n      return errorResponse(message, 500);\n    }\n  },\n\n  /**\n   * Scheduled (Cron) Handler\n   * Runs every 6 hours to sync data\n   */\n  async scheduled(event: ScheduledEvent, env: Env, ctx: ExecutionContext): Promise<void> {\n    const cronTime = event.cron;\n    console.log(`Cron triggered: ${cronTime} at ${new Date().toISOString()}`);\n\n    try {\n      // Every 6 hours: run all syncs\n      if (cronTime === '0 */6 * * *') {\n        // 1. Sync places from Google Sheet\n        console.log('Running: sheets-sync');\n        await syncPlacesFromSheet(env);\n\n        // 2. Sync weather and nearby places for all user locations\n        console.log('Running: places-and-weather');\n        await runPlacesAndWeatherSync(env);\n\n        // 3. Sync YouTube videos\n        console.log('Running: youtube-sync');\n        await runYouTubeSync(env);\n      }\n\n      console.log('Cron jobs completed successfully');\n    } catch (error) {\n      console.error('Cron error:', error);\n    }\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\src\\\\index.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\src\\\\index.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\.wrangler\\\\tmp\\\\bundle-V5gIrh\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\.wrangler\\\\tmp\\\\bundle-V5gIrh\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"D:\\\\AI\\\\aleksandras-2-dalis\\\\dashboard\\\\worker\\\\.wrangler\\\\tmp\\\\bundle-V5gIrh\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
